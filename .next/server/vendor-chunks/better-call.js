"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/better-call";
exports.ids = ["vendor-chunks/better-call"];
exports.modules = {

/***/ "(rsc)/./node_modules/better-call/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/better-call/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),\n/* harmony export */   createEndpointCreator: () => (/* binding */ createEndpointCreator),\n/* harmony export */   createMiddleware: () => (/* binding */ createMiddleware),\n/* harmony export */   createMiddlewareCreator: () => (/* binding */ createMiddlewareCreator),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   getBody: () => (/* binding */ getBody),\n/* harmony export */   getCookie: () => (/* binding */ getCookie),\n/* harmony export */   getRequest: () => (/* binding */ getRequest),\n/* harmony export */   getSignedCookie: () => (/* binding */ getSignedCookie),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseSigned: () => (/* binding */ parseSigned),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeSigned: () => (/* binding */ serializeSigned),\n/* harmony export */   setCookie: () => (/* binding */ setCookie),\n/* harmony export */   setResponse: () => (/* binding */ setResponse),\n/* harmony export */   setSignedCookie: () => (/* binding */ setSignedCookie),\n/* harmony export */   shouldSerialize: () => (/* binding */ shouldSerialize),\n/* harmony export */   signCookieValue: () => (/* binding */ signCookieValue),\n/* harmony export */   statusCode: () => (/* binding */ statusCode),\n/* harmony export */   toNodeHandler: () => (/* binding */ toNodeHandler)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/ZodError.js\");\n/* harmony import */ var uncrypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uncrypto */ \"(rsc)/./node_modules/uncrypto/dist/crypto.node.mjs\");\n/* harmony import */ var rou3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rou3 */ \"(rsc)/./node_modules/rou3/dist/index.mjs\");\n/* harmony import */ var set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! set-cookie-parser */ \"(rsc)/./node_modules/set-cookie-parser/lib/set-cookie.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/endpoint.ts\n\n\n// src/error.ts\nvar APIError = class extends Error {\n  constructor(status, body, headers) {\n    super(`API Error: ${status} ${body?.message ?? \"\"}`, {\n      cause: body\n    });\n    __publicField(this, \"status\");\n    __publicField(this, \"headers\");\n    __publicField(this, \"body\");\n    this.status = status;\n    this.body = body ?? {};\n    this.stack = \"\";\n    this.headers = headers ?? new Headers();\n    if (!this.headers.has(\"Content-Type\")) {\n      this.headers.set(\"Content-Type\", \"application/json\");\n    }\n    this.name = \"BetterCallAPIError\";\n  }\n};\n\n// src/helper.ts\nvar json = (body, option) => {\n  return {\n    response: {\n      body: option?.body ?? body,\n      status: option?.status ?? 200,\n      statusText: option?.statusText ?? \"OK\",\n      headers: option?.headers\n    },\n    body,\n    _flag: \"json\"\n  };\n};\n\n// src/cookie.ts\n\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch (e) {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  const pairs = cookie.trim().split(\";\");\n  return pairs.reduce((parsedCookie, pairStr) => {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      return parsedCookie;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      return parsedCookie;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent(cookieValue);\n    }\n    return parsedCookie;\n  }, {});\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    opt.secure = true;\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    if (opt.path !== \"/\") {\n      opt.path = \"/\";\n    }\n    if (opt.domain) {\n      opt.domain = void 0;\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar signCookieValue = async (value, secret) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return value;\n};\n\n// src/cookie-utils.ts\nvar getCookie = (cookie, key, prefix) => {\n  if (!cookie) {\n    return void 0;\n  }\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    } else {\n      return void 0;\n    }\n  }\n  const obj = parse(cookie, finalKey);\n  return obj[finalKey];\n};\nvar setCookie = (header, name, value, opt) => {\n  const existingCookies = header.get(\"Set-Cookie\");\n  if (existingCookies) {\n    const cookies = existingCookies.split(\", \");\n    const updatedCookies = cookies.filter((cookie2) => !cookie2.startsWith(`${name}=`));\n    header.delete(\"Set-Cookie\");\n    updatedCookies.forEach((cookie2) => header.append(\"Set-Cookie\", cookie2));\n  }\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = serialize(\"__Secure-\" + name, value, { path: \"/\", ...opt, secure: true });\n  } else if (opt?.prefix === \"host\") {\n    cookie = serialize(\"__Host-\" + name, value, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = serialize(name, value, { path: \"/\", ...opt });\n  }\n  header.append(\"Set-Cookie\", cookie);\n};\nvar setSignedCookie = async (header, name, value, secret, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = await serializeSigned(\"__Secure-\" + name, value, secret, {\n      path: \"/\",\n      ...opt,\n      secure: true\n    });\n  } else if (opt?.prefix === \"host\") {\n    cookie = await serializeSigned(\"__Host-\" + name, value, secret, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = await serializeSigned(name, value, secret, { path: \"/\", ...opt });\n  }\n  header.append(\"Set-Cookie\", cookie);\n};\nvar getSignedCookie = async (header, secret, key, prefix) => {\n  const cookie = header.get(\"cookie\");\n  if (!cookie) {\n    return void 0;\n  }\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n  }\n  const obj = await parseSigned(cookie, secret, finalKey);\n  return obj[finalKey];\n};\n\n// src/endpoint.ts\nfunction createEndpointCreator(opts) {\n  return (path, options, handler) => {\n    return createEndpoint(\n      path,\n      {\n        ...options,\n        use: [...options?.use || [], ...opts?.use || []]\n      },\n      handler\n    );\n  };\n}\nfunction createEndpoint(path, options, handler) {\n  let responseHeader = new Headers();\n  const handle = async (...ctx) => {\n    let internalCtx = {\n      setHeader(key, value) {\n        responseHeader.set(key, value);\n      },\n      setCookie(key, value, options2) {\n        setCookie(responseHeader, key, value, options2);\n      },\n      getCookie(key, prefix) {\n        const header = ctx[0]?.headers;\n        const cookieH = header?.get(\"cookie\");\n        const cookie = getCookie(cookieH || \"\", key, prefix);\n        return cookie;\n      },\n      getSignedCookie(key, secret, prefix) {\n        const header = ctx[0]?.headers;\n        if (!header) {\n          throw new TypeError(\"Headers are required\");\n        }\n        const cookie = getSignedCookie(header, secret, key, prefix);\n        return cookie;\n      },\n      async setSignedCookie(key, value, secret, options2) {\n        await setSignedCookie(responseHeader, key, value, secret, options2);\n      },\n      redirect(url) {\n        responseHeader.set(\"Location\", url);\n        return new APIError(\"FOUND\");\n      },\n      json,\n      context: ctx[0]?.context || {},\n      _flag: ctx[0]?.asResponse ? \"router\" : ctx[0]?._flag,\n      responseHeader,\n      path,\n      ...ctx[0] || {}\n    };\n    if (options.use?.length) {\n      let middlewareContexts = {};\n      let middlewareBody = {};\n      for (const middleware of options.use) {\n        if (typeof middleware !== \"function\") {\n          console.warn(\"Middleware is not a function\", {\n            middleware\n          });\n          continue;\n        }\n        const res = await middleware(internalCtx);\n        if (res) {\n          const body = res.options?.body ? res.options.body.parse(internalCtx.body) : void 0;\n          middlewareContexts = {\n            ...middlewareContexts,\n            ...res\n          };\n          middlewareBody = {\n            ...middlewareBody,\n            ...body\n          };\n        }\n      }\n      internalCtx = {\n        ...internalCtx,\n        body: {\n          ...middlewareBody,\n          ...internalCtx.body\n        },\n        context: {\n          ...internalCtx.context || {},\n          ...middlewareContexts\n        }\n      };\n    }\n    try {\n      const body = options.body ? options.body.parse(internalCtx.body) : internalCtx.body;\n      internalCtx = {\n        ...internalCtx,\n        body: body ? {\n          ...body,\n          ...internalCtx.body\n        } : internalCtx.body\n      };\n      internalCtx.query = options.query ? options.query.parse(internalCtx.query) : internalCtx.query;\n    } catch (e) {\n      if (e instanceof zod__WEBPACK_IMPORTED_MODULE_1__.ZodError) {\n        throw new APIError(\"BAD_REQUEST\", {\n          message: e.message,\n          details: e.errors\n        });\n      }\n      throw e;\n    }\n    if (options.requireHeaders && !internalCtx.headers) {\n      throw new APIError(\"BAD_REQUEST\", {\n        message: \"Headers are required\"\n      });\n    }\n    if (options.requireRequest && !internalCtx.request) {\n      throw new APIError(\"BAD_REQUEST\", {\n        message: \"Request is required\"\n      });\n    }\n    try {\n      let res = await handler(internalCtx);\n      let actualResponse = res;\n      if (res && typeof res === \"object\" && \"_flag\" in res) {\n        if (res._flag === \"json\" && internalCtx._flag === \"router\") {\n          const h = res.response.headers;\n          Object.keys(h || {}).forEach((key) => {\n            responseHeader.set(key, h[key]);\n          });\n          responseHeader.set(\"Content-Type\", \"application/json\");\n          actualResponse = new Response(JSON.stringify(res.response.body), {\n            status: res.response.status ?? 200,\n            statusText: res.response.statusText,\n            headers: responseHeader\n          });\n        } else {\n          actualResponse = res.body;\n        }\n      }\n      responseHeader = new Headers();\n      return actualResponse;\n    } catch (e) {\n      if (e instanceof APIError) {\n        responseHeader.set(\"Content-Type\", \"application/json\");\n        e.headers = responseHeader;\n        responseHeader = new Headers();\n        throw e;\n      }\n      throw e;\n    }\n  };\n  handle.path = path;\n  handle.options = options;\n  handle.method = options.method;\n  handle.headers = responseHeader;\n  return handle;\n}\n\n// src/router.ts\n\n\n// src/utils.ts\nasync function getBody(request) {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!request.body) {\n    return void 0;\n  }\n  if (contentType.includes(\"application/json\")) {\n    return await request.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value.toString();\n    });\n    return result;\n  }\n  if (contentType.includes(\"multipart/form-data\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value;\n    });\n    return result;\n  }\n  if (contentType.includes(\"text/plain\")) {\n    return await request.text();\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return await request.arrayBuffer();\n  }\n  if (contentType.includes(\"application/pdf\") || contentType.includes(\"image/\") || contentType.includes(\"video/\")) {\n    const blob = await request.blob();\n    return blob;\n  }\n  if (contentType.includes(\"application/stream\") || request.body instanceof ReadableStream) {\n    return request.body;\n  }\n  return await request.text();\n}\nfunction shouldSerialize(body) {\n  return typeof body === \"object\" && body !== null && !(body instanceof Blob) && !(body instanceof FormData);\n}\nvar statusCode = {\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NO_CONTENT: 204,\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  TEMPORARY_REDIRECT: 307,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  \"I'M_A_TEAPOT\": 418,\n  MISDIRECTED_REQUEST: 421,\n  UNPROCESSABLE_ENTITY: 422,\n  LOCKED: 423,\n  FAILED_DEPENDENCY: 424,\n  TOO_EARLY: 425,\n  UPGRADE_REQUIRED: 426,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505,\n  VARIANT_ALSO_NEGOTIATES: 506,\n  INSUFFICIENT_STORAGE: 507,\n  LOOP_DETECTED: 508,\n  NOT_EXTENDED: 510,\n  NETWORK_AUTHENTICATION_REQUIRED: 511\n};\n\n// src/router.ts\nvar createRouter = (endpoints, config) => {\n  const _endpoints = Object.values(endpoints);\n  const router = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.createRouter)();\n  for (const endpoint of _endpoints) {\n    if (endpoint.options.metadata?.SERVER_ONLY) continue;\n    if (Array.isArray(endpoint.options?.method)) {\n      for (const method of endpoint.options.method) {\n        (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(router, method, endpoint.path, endpoint);\n      }\n    } else {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(router, endpoint.options.method, endpoint.path, endpoint);\n    }\n  }\n  const middlewareRouter = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.createRouter)();\n  for (const route of config?.routerMiddleware || []) {\n    (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(middlewareRouter, \"*\", route.path, route.middleware);\n  }\n  const handler = async (request) => {\n    const url = new URL(request.url);\n    let path = url.pathname;\n    if (config?.basePath) {\n      path = path.split(config.basePath)[1];\n    }\n    if (!path?.length) {\n      config?.onError?.(new APIError(\"NOT_FOUND\"));\n      console.warn(\n        `[better-call]: Make sure the URL has the basePath (${config?.basePath}).`\n      );\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not Found\"\n      });\n    }\n    const method = request.method;\n    const route = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.findRoute)(router, method, path);\n    const handler2 = route?.data;\n    const body = await getBody(request);\n    const headers = request.headers;\n    const query = Object.fromEntries(url.searchParams);\n    const routerMiddleware = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.findAllRoutes)(middlewareRouter, \"*\", path);\n    if (!handler2) {\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not Found\"\n      });\n    }\n    try {\n      let middlewareContext = {};\n      if (routerMiddleware?.length) {\n        for (const route2 of routerMiddleware) {\n          const middleware = route2.data;\n          const res = await middleware({\n            path,\n            method,\n            headers,\n            params: route2?.params,\n            request,\n            body,\n            query,\n            context: {\n              ...config?.extraContext\n            }\n          });\n          if (res instanceof Response) {\n            return res;\n          }\n          if (res?._flag === \"json\") {\n            return new Response(JSON.stringify(res), {\n              headers: res.headers\n            });\n          }\n          if (res) {\n            middlewareContext = {\n              ...res,\n              ...middlewareContext\n            };\n          }\n        }\n      }\n      const handlerRes = await handler2({\n        path,\n        method,\n        headers,\n        params: route?.params,\n        request,\n        body,\n        query,\n        _flag: \"router\",\n        context: {\n          ...middlewareContext,\n          ...config?.extraContext\n        }\n      });\n      if (handlerRes instanceof Response) {\n        return handlerRes;\n      }\n      const resBody = shouldSerialize(handlerRes) ? JSON.stringify(handlerRes) : handlerRes;\n      return new Response(resBody, {\n        headers: handler2.headers\n      });\n    } catch (e) {\n      if (config?.onError) {\n        const onErrorRes = await config.onError(e);\n        if (onErrorRes instanceof Response) {\n          return onErrorRes;\n        }\n      }\n      if (e instanceof APIError) {\n        return new Response(e.body ? JSON.stringify(e.body) : null, {\n          status: statusCode[e.status],\n          statusText: e.status,\n          headers: e.headers\n        });\n      }\n      if (config?.throwError) {\n        throw e;\n      }\n      return new Response(null, {\n        status: 500,\n        statusText: \"Internal Server Error\"\n      });\n    }\n  };\n  return {\n    handler: async (request) => {\n      const onReq = await config?.onRequest?.(request);\n      if (onReq instanceof Response) {\n        return onReq;\n      }\n      const req = onReq instanceof Request ? onReq : request;\n      const res = await handler(req);\n      const onRes = await config?.onResponse?.(res);\n      if (onRes instanceof Response) {\n        return onRes;\n      }\n      return res;\n    },\n    endpoints\n  };\n};\n\n// src/middleware.ts\nfunction createMiddleware(optionsOrHandler, handler) {\n  if (typeof optionsOrHandler === \"function\") {\n    return createEndpoint(\n      \"*\",\n      {\n        method: \"*\"\n      },\n      optionsOrHandler\n    );\n  }\n  if (!handler) {\n    throw new Error(\"Middleware handler is required\");\n  }\n  const endpoint = createEndpoint(\n    \"*\",\n    {\n      ...optionsOrHandler,\n      method: \"*\"\n    },\n    handler\n  );\n  return endpoint;\n}\nvar createMiddlewareCreator = (opts) => {\n  function fn(optionsOrHandler, handler) {\n    if (typeof optionsOrHandler === \"function\") {\n      return createEndpoint(\n        \"*\",\n        {\n          method: \"*\"\n        },\n        optionsOrHandler\n      );\n    }\n    if (!handler) {\n      throw new Error(\"Middleware handler is required\");\n    }\n    const endpoint = createEndpoint(\n      \"*\",\n      {\n        ...optionsOrHandler,\n        method: \"*\"\n      },\n      handler\n    );\n    return endpoint;\n  }\n  return fn;\n};\n\n// src/types.ts\n\n\n// src/adapter/request.ts\n\nfunction get_raw_body(req, body_size_limit) {\n  const h = req.headers;\n  if (!h[\"content-type\"]) return null;\n  const content_length = Number(h[\"content-length\"]);\n  if (req.httpVersionMajor === 1 && isNaN(content_length) && h[\"transfer-encoding\"] == null || content_length === 0) {\n    return null;\n  }\n  let length = content_length;\n  if (body_size_limit) {\n    if (!length) {\n      length = body_size_limit;\n    } else if (length > body_size_limit) {\n      throw Error(\n        `Received content-length of ${length}, but only accept up to ${body_size_limit} bytes.`\n      );\n    }\n  }\n  if (req.destroyed) {\n    const readable = new ReadableStream();\n    readable.cancel();\n    return readable;\n  }\n  let size = 0;\n  let cancelled = false;\n  return new ReadableStream({\n    start(controller) {\n      req.on(\"error\", (error) => {\n        cancelled = true;\n        controller.error(error);\n      });\n      req.on(\"end\", () => {\n        if (cancelled) return;\n        controller.close();\n      });\n      req.on(\"data\", (chunk) => {\n        if (cancelled) return;\n        size += chunk.length;\n        if (size > length) {\n          cancelled = true;\n          controller.error(\n            new Error(\n              `request body size exceeded ${content_length ? \"'content-length'\" : \"BODY_SIZE_LIMIT\"} of ${length}`\n            )\n          );\n          return;\n        }\n        controller.enqueue(chunk);\n        if (controller.desiredSize === null || controller.desiredSize <= 0) {\n          req.pause();\n        }\n      });\n    },\n    pull() {\n      req.resume();\n    },\n    cancel(reason) {\n      cancelled = true;\n      req.destroy(reason);\n    }\n  });\n}\nfunction getRequest({\n  request,\n  base,\n  bodySizeLimit\n}) {\n  return new Request(base + request.url, {\n    // @ts-expect-error\n    duplex: \"half\",\n    method: request.method,\n    body: get_raw_body(request, bodySizeLimit),\n    headers: request.headers\n  });\n}\nasync function setResponse(res, response) {\n  for (const [key, value] of response.headers) {\n    try {\n      res.setHeader(\n        key,\n        key === \"set-cookie\" ? set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__.splitCookiesString(response.headers.get(key)) : value\n      );\n    } catch (error) {\n      res.getHeaderNames().forEach((name) => res.removeHeader(name));\n      res.writeHead(500).end(String(error));\n      return;\n    }\n  }\n  res.writeHead(response.status);\n  if (!response.body) {\n    res.end();\n    return;\n  }\n  if (response.body.locked) {\n    res.end(\n      \"Fatal error: Response body is locked. This can happen when the response was already read (for example through 'response.json()' or 'response.text()').\"\n    );\n    return;\n  }\n  const reader = response.body.getReader();\n  if (res.destroyed) {\n    reader.cancel();\n    return;\n  }\n  const cancel = (error) => {\n    res.off(\"close\", cancel);\n    res.off(\"error\", cancel);\n    reader.cancel(error).catch(() => {\n    });\n    if (error) res.destroy(error);\n  };\n  res.on(\"close\", cancel);\n  res.on(\"error\", cancel);\n  next();\n  async function next() {\n    try {\n      for (; ; ) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        if (!res.write(value)) {\n          res.once(\"drain\", next);\n          return;\n        }\n      }\n      res.end();\n    } catch (error) {\n      cancel(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n}\n\n// src/adapter/node.ts\nfunction toNodeHandler(handler) {\n  return async (req, res) => {\n    const protocol = req.connection?.encrypted ? \"https\" : \"http\";\n    const base = `${protocol}://${req.headers[\":authority\"] || req.headers.host}`;\n    const response = await handler(getRequest({ base, request: req }));\n    setResponse(res, response);\n  };\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmV0dGVyLWNhbGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJOztBQUVBO0FBQytCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUSxFQUFFLG9CQUFvQjtBQUN0RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2tDO0FBQ2xDLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZSw0Q0FBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNENBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBLGlCQUFpQiw0Q0FBTTtBQUN2QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtCQUFrQixLQUFLLEdBQUcsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseURBQXlELEtBQUssT0FBTztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpRUFBb0M7QUFDbkU7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxLQUFLLDhDQUE4QztBQUNoRixnREFBZ0Qsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQXVCRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXR0YWNrLWNhcGl0YWwtdGFzay8uL25vZGVfbW9kdWxlcy9iZXR0ZXItY2FsbC9kaXN0L2luZGV4LmpzPzk1ZWMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcblxuLy8gc3JjL2VuZHBvaW50LnRzXG5pbXBvcnQgeyBab2RFcnJvciB9IGZyb20gXCJ6b2RcIjtcblxuLy8gc3JjL2Vycm9yLnRzXG52YXIgQVBJRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgc3VwZXIoYEFQSSBFcnJvcjogJHtzdGF0dXN9ICR7Ym9keT8ubWVzc2FnZSA/PyBcIlwifWAsIHtcbiAgICAgIGNhdXNlOiBib2R5XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0YXR1c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGVhZGVyc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYm9keVwiKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmJvZHkgPSBib2R5ID8/IHt9O1xuICAgIHRoaXMuc3RhY2sgPSBcIlwiO1xuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnMgPz8gbmV3IEhlYWRlcnMoKTtcbiAgICBpZiAoIXRoaXMuaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICAgIHRoaXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBcIkJldHRlckNhbGxBUElFcnJvclwiO1xuICB9XG59O1xuXG4vLyBzcmMvaGVscGVyLnRzXG52YXIganNvbiA9IChib2R5LCBvcHRpb24pID0+IHtcbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZToge1xuICAgICAgYm9keTogb3B0aW9uPy5ib2R5ID8/IGJvZHksXG4gICAgICBzdGF0dXM6IG9wdGlvbj8uc3RhdHVzID8/IDIwMCxcbiAgICAgIHN0YXR1c1RleHQ6IG9wdGlvbj8uc3RhdHVzVGV4dCA/PyBcIk9LXCIsXG4gICAgICBoZWFkZXJzOiBvcHRpb24/LmhlYWRlcnNcbiAgICB9LFxuICAgIGJvZHksXG4gICAgX2ZsYWc6IFwianNvblwiXG4gIH07XG59O1xuXG4vLyBzcmMvY29va2llLnRzXG5pbXBvcnQgeyBzdWJ0bGUgfSBmcm9tIFwidW5jcnlwdG9cIjtcbnZhciBhbGdvcml0aG0gPSB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9O1xudmFyIGdldENyeXB0b0tleSA9IGFzeW5jIChzZWNyZXQpID0+IHtcbiAgY29uc3Qgc2VjcmV0QnVmID0gdHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIiA/IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzZWNyZXQpIDogc2VjcmV0O1xuICByZXR1cm4gYXdhaXQgc3VidGxlLmltcG9ydEtleShcInJhd1wiLCBzZWNyZXRCdWYsIGFsZ29yaXRobSwgZmFsc2UsIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl0pO1xufTtcbnZhciBtYWtlU2lnbmF0dXJlID0gYXN5bmMgKHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgY29uc3Qga2V5ID0gYXdhaXQgZ2V0Q3J5cHRvS2V5KHNlY3JldCk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHN1YnRsZS5zaWduKGFsZ29yaXRobS5uYW1lLCBrZXksIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSkpO1xuICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLm5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpKTtcbn07XG52YXIgdmVyaWZ5U2lnbmF0dXJlID0gYXN5bmMgKGJhc2U2NFNpZ25hdHVyZSwgdmFsdWUsIHNlY3JldCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHNpZ25hdHVyZUJpblN0ciA9IGF0b2IoYmFzZTY0U2lnbmF0dXJlKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBuZXcgVWludDhBcnJheShzaWduYXR1cmVCaW5TdHIubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc2lnbmF0dXJlQmluU3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzaWduYXR1cmVbaV0gPSBzaWduYXR1cmVCaW5TdHIuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHN1YnRsZS52ZXJpZnkoYWxnb3JpdGhtLCBzZWNyZXQsIHNpZ25hdHVyZSwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgdmFsaWRDb29raWVOYW1lUmVnRXggPSAvXltcXHchIyQlJicqLl5gfH4rLV0rJC87XG52YXIgdmFsaWRDb29raWVWYWx1ZVJlZ0V4ID0gL15bICEjLTo8LVtcXF0tfl0qJC87XG52YXIgcGFyc2UgPSAoY29va2llLCBuYW1lKSA9PiB7XG4gIGNvbnN0IHBhaXJzID0gY29va2llLnRyaW0oKS5zcGxpdChcIjtcIik7XG4gIHJldHVybiBwYWlycy5yZWR1Y2UoKHBhcnNlZENvb2tpZSwgcGFpclN0cikgPT4ge1xuICAgIHBhaXJTdHIgPSBwYWlyU3RyLnRyaW0oKTtcbiAgICBjb25zdCB2YWx1ZVN0YXJ0UG9zID0gcGFpclN0ci5pbmRleE9mKFwiPVwiKTtcbiAgICBpZiAodmFsdWVTdGFydFBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBwYXJzZWRDb29raWU7XG4gICAgfVxuICAgIGNvbnN0IGNvb2tpZU5hbWUgPSBwYWlyU3RyLnN1YnN0cmluZygwLCB2YWx1ZVN0YXJ0UG9zKS50cmltKCk7XG4gICAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gY29va2llTmFtZSB8fCAhdmFsaWRDb29raWVOYW1lUmVnRXgudGVzdChjb29raWVOYW1lKSkge1xuICAgICAgcmV0dXJuIHBhcnNlZENvb2tpZTtcbiAgICB9XG4gICAgbGV0IGNvb2tpZVZhbHVlID0gcGFpclN0ci5zdWJzdHJpbmcodmFsdWVTdGFydFBvcyArIDEpLnRyaW0oKTtcbiAgICBpZiAoY29va2llVmFsdWUuc3RhcnRzV2l0aCgnXCInKSAmJiBjb29raWVWYWx1ZS5lbmRzV2l0aCgnXCInKSkge1xuICAgICAgY29va2llVmFsdWUgPSBjb29raWVWYWx1ZS5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIGlmICh2YWxpZENvb2tpZVZhbHVlUmVnRXgudGVzdChjb29raWVWYWx1ZSkpIHtcbiAgICAgIHBhcnNlZENvb2tpZVtjb29raWVOYW1lXSA9IGRlY29kZVVSSUNvbXBvbmVudChjb29raWVWYWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRDb29raWU7XG4gIH0sIHt9KTtcbn07XG52YXIgcGFyc2VTaWduZWQgPSBhc3luYyAoY29va2llLCBzZWNyZXQsIG5hbWUpID0+IHtcbiAgY29uc3QgcGFyc2VkQ29va2llID0ge307XG4gIGNvbnN0IHNlY3JldEtleSA9IGF3YWl0IGdldENyeXB0b0tleShzZWNyZXQpO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJzZShjb29raWUsIG5hbWUpKSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZVN0YXJ0UG9zID0gdmFsdWUubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChzaWduYXR1cmVTdGFydFBvcyA8IDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzaWduZWRWYWx1ZSA9IHZhbHVlLnN1YnN0cmluZygwLCBzaWduYXR1cmVTdGFydFBvcyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsdWUuc3Vic3RyaW5nKHNpZ25hdHVyZVN0YXJ0UG9zICsgMSk7XG4gICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDQ0IHx8ICFzaWduYXR1cmUuZW5kc1dpdGgoXCI9XCIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXNWZXJpZmllZCA9IGF3YWl0IHZlcmlmeVNpZ25hdHVyZShzaWduYXR1cmUsIHNpZ25lZFZhbHVlLCBzZWNyZXRLZXkpO1xuICAgIHBhcnNlZENvb2tpZVtrZXldID0gaXNWZXJpZmllZCA/IHNpZ25lZFZhbHVlIDogZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZENvb2tpZTtcbn07XG52YXIgX3NlcmlhbGl6ZSA9IChuYW1lLCB2YWx1ZSwgb3B0ID0ge30pID0+IHtcbiAgbGV0IGNvb2tpZSA9IGAke25hbWV9PSR7dmFsdWV9YDtcbiAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIl9fU2VjdXJlLVwiKSAmJiAhb3B0LnNlY3VyZSkge1xuICAgIG9wdC5zZWN1cmUgPSB0cnVlO1xuICB9XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJfX0hvc3QtXCIpKSB7XG4gICAgaWYgKCFvcHQuc2VjdXJlKSB7XG4gICAgICBvcHQuc2VjdXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdC5wYXRoICE9PSBcIi9cIikge1xuICAgICAgb3B0LnBhdGggPSBcIi9cIjtcbiAgICB9XG4gICAgaWYgKG9wdC5kb21haW4pIHtcbiAgICAgIG9wdC5kb21haW4gPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmIChvcHQgJiYgdHlwZW9mIG9wdC5tYXhBZ2UgPT09IFwibnVtYmVyXCIgJiYgb3B0Lm1heEFnZSA+PSAwKSB7XG4gICAgaWYgKG9wdC5tYXhBZ2UgPiAzNDU2ZTQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVzIE1heC1BZ2UgU0hPVUxEIE5PVCBiZSBncmVhdGVyIHRoYW4gNDAwIGRheXMgKDM0NTYwMDAwIHNlY29uZHMpIGluIGR1cmF0aW9uLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb29raWUgKz0gYDsgTWF4LUFnZT0ke01hdGguZmxvb3Iob3B0Lm1heEFnZSl9YDtcbiAgfVxuICBpZiAob3B0LmRvbWFpbiAmJiBvcHQucHJlZml4ICE9PSBcImhvc3RcIikge1xuICAgIGNvb2tpZSArPSBgOyBEb21haW49JHtvcHQuZG9tYWlufWA7XG4gIH1cbiAgaWYgKG9wdC5wYXRoKSB7XG4gICAgY29va2llICs9IGA7IFBhdGg9JHtvcHQucGF0aH1gO1xuICB9XG4gIGlmIChvcHQuZXhwaXJlcykge1xuICAgIGlmIChvcHQuZXhwaXJlcy5nZXRUaW1lKCkgLSBEYXRlLm5vdygpID4gMzQ1NmU3KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ29va2llcyBFeHBpcmVzIFNIT1VMRCBOT1QgYmUgZ3JlYXRlciB0aGFuIDQwMCBkYXlzICgzNDU2MDAwMCBzZWNvbmRzKSBpbiB0aGUgZnV0dXJlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb29raWUgKz0gYDsgRXhwaXJlcz0ke29wdC5leHBpcmVzLnRvVVRDU3RyaW5nKCl9YDtcbiAgfVxuICBpZiAob3B0Lmh0dHBPbmx5KSB7XG4gICAgY29va2llICs9IFwiOyBIdHRwT25seVwiO1xuICB9XG4gIGlmIChvcHQuc2VjdXJlKSB7XG4gICAgY29va2llICs9IFwiOyBTZWN1cmVcIjtcbiAgfVxuICBpZiAob3B0LnNhbWVTaXRlKSB7XG4gICAgY29va2llICs9IGA7IFNhbWVTaXRlPSR7b3B0LnNhbWVTaXRlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3B0LnNhbWVTaXRlLnNsaWNlKDEpfWA7XG4gIH1cbiAgaWYgKG9wdC5wYXJ0aXRpb25lZCkge1xuICAgIGlmICghb3B0LnNlY3VyZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFydGl0aW9uZWQgQ29va2llIG11c3QgaGF2ZSBTZWN1cmUgYXR0cmlidXRlc1wiKTtcbiAgICB9XG4gICAgY29va2llICs9IFwiOyBQYXJ0aXRpb25lZFwiO1xuICB9XG4gIHJldHVybiBjb29raWU7XG59O1xudmFyIHNlcmlhbGl6ZSA9IChuYW1lLCB2YWx1ZSwgb3B0KSA9PiB7XG4gIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgcmV0dXJuIF9zZXJpYWxpemUobmFtZSwgdmFsdWUsIG9wdCk7XG59O1xudmFyIHNlcmlhbGl6ZVNpZ25lZCA9IGFzeW5jIChuYW1lLCB2YWx1ZSwgc2VjcmV0LCBvcHQgPSB7fSkgPT4ge1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBtYWtlU2lnbmF0dXJlKHZhbHVlLCBzZWNyZXQpO1xuICB2YWx1ZSA9IGAke3ZhbHVlfS4ke3NpZ25hdHVyZX1gO1xuICB2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIHJldHVybiBfc2VyaWFsaXplKG5hbWUsIHZhbHVlLCBvcHQpO1xufTtcbnZhciBzaWduQ29va2llVmFsdWUgPSBhc3luYyAodmFsdWUsIHNlY3JldCkgPT4ge1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBtYWtlU2lnbmF0dXJlKHZhbHVlLCBzZWNyZXQpO1xuICB2YWx1ZSA9IGAke3ZhbHVlfS4ke3NpZ25hdHVyZX1gO1xuICB2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIHNyYy9jb29raWUtdXRpbHMudHNcbnZhciBnZXRDb29raWUgPSAoY29va2llLCBrZXksIHByZWZpeCkgPT4ge1xuICBpZiAoIWNvb2tpZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IGZpbmFsS2V5ID0ga2V5O1xuICBpZiAocHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgZmluYWxLZXkgPSBcIl9fU2VjdXJlLVwiICsga2V5O1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSBcImhvc3RcIikge1xuICAgICAgZmluYWxLZXkgPSBcIl9fSG9zdC1cIiArIGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb2JqID0gcGFyc2UoY29va2llLCBmaW5hbEtleSk7XG4gIHJldHVybiBvYmpbZmluYWxLZXldO1xufTtcbnZhciBzZXRDb29raWUgPSAoaGVhZGVyLCBuYW1lLCB2YWx1ZSwgb3B0KSA9PiB7XG4gIGNvbnN0IGV4aXN0aW5nQ29va2llcyA9IGhlYWRlci5nZXQoXCJTZXQtQ29va2llXCIpO1xuICBpZiAoZXhpc3RpbmdDb29raWVzKSB7XG4gICAgY29uc3QgY29va2llcyA9IGV4aXN0aW5nQ29va2llcy5zcGxpdChcIiwgXCIpO1xuICAgIGNvbnN0IHVwZGF0ZWRDb29raWVzID0gY29va2llcy5maWx0ZXIoKGNvb2tpZTIpID0+ICFjb29raWUyLnN0YXJ0c1dpdGgoYCR7bmFtZX09YCkpO1xuICAgIGhlYWRlci5kZWxldGUoXCJTZXQtQ29va2llXCIpO1xuICAgIHVwZGF0ZWRDb29raWVzLmZvckVhY2goKGNvb2tpZTIpID0+IGhlYWRlci5hcHBlbmQoXCJTZXQtQ29va2llXCIsIGNvb2tpZTIpKTtcbiAgfVxuICBsZXQgY29va2llO1xuICBpZiAob3B0Py5wcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICBjb29raWUgPSBzZXJpYWxpemUoXCJfX1NlY3VyZS1cIiArIG5hbWUsIHZhbHVlLCB7IHBhdGg6IFwiL1wiLCAuLi5vcHQsIHNlY3VyZTogdHJ1ZSB9KTtcbiAgfSBlbHNlIGlmIChvcHQ/LnByZWZpeCA9PT0gXCJob3N0XCIpIHtcbiAgICBjb29raWUgPSBzZXJpYWxpemUoXCJfX0hvc3QtXCIgKyBuYW1lLCB2YWx1ZSwge1xuICAgICAgLi4ub3B0LFxuICAgICAgcGF0aDogXCIvXCIsXG4gICAgICBzZWN1cmU6IHRydWUsXG4gICAgICBkb21haW46IHZvaWQgMFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvb2tpZSA9IHNlcmlhbGl6ZShuYW1lLCB2YWx1ZSwgeyBwYXRoOiBcIi9cIiwgLi4ub3B0IH0pO1xuICB9XG4gIGhlYWRlci5hcHBlbmQoXCJTZXQtQ29va2llXCIsIGNvb2tpZSk7XG59O1xudmFyIHNldFNpZ25lZENvb2tpZSA9IGFzeW5jIChoZWFkZXIsIG5hbWUsIHZhbHVlLCBzZWNyZXQsIG9wdCkgPT4ge1xuICBsZXQgY29va2llO1xuICBpZiAob3B0Py5wcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICBjb29raWUgPSBhd2FpdCBzZXJpYWxpemVTaWduZWQoXCJfX1NlY3VyZS1cIiArIG5hbWUsIHZhbHVlLCBzZWNyZXQsIHtcbiAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgLi4ub3B0LFxuICAgICAgc2VjdXJlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAob3B0Py5wcmVmaXggPT09IFwiaG9zdFwiKSB7XG4gICAgY29va2llID0gYXdhaXQgc2VyaWFsaXplU2lnbmVkKFwiX19Ib3N0LVwiICsgbmFtZSwgdmFsdWUsIHNlY3JldCwge1xuICAgICAgLi4ub3B0LFxuICAgICAgcGF0aDogXCIvXCIsXG4gICAgICBzZWN1cmU6IHRydWUsXG4gICAgICBkb21haW46IHZvaWQgMFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvb2tpZSA9IGF3YWl0IHNlcmlhbGl6ZVNpZ25lZChuYW1lLCB2YWx1ZSwgc2VjcmV0LCB7IHBhdGg6IFwiL1wiLCAuLi5vcHQgfSk7XG4gIH1cbiAgaGVhZGVyLmFwcGVuZChcIlNldC1Db29raWVcIiwgY29va2llKTtcbn07XG52YXIgZ2V0U2lnbmVkQ29va2llID0gYXN5bmMgKGhlYWRlciwgc2VjcmV0LCBrZXksIHByZWZpeCkgPT4ge1xuICBjb25zdCBjb29raWUgPSBoZWFkZXIuZ2V0KFwiY29va2llXCIpO1xuICBpZiAoIWNvb2tpZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IGZpbmFsS2V5ID0ga2V5O1xuICBpZiAocHJlZml4KSB7XG4gICAgaWYgKHByZWZpeCA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgZmluYWxLZXkgPSBcIl9fU2VjdXJlLVwiICsga2V5O1xuICAgIH0gZWxzZSBpZiAocHJlZml4ID09PSBcImhvc3RcIikge1xuICAgICAgZmluYWxLZXkgPSBcIl9fSG9zdC1cIiArIGtleTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgb2JqID0gYXdhaXQgcGFyc2VTaWduZWQoY29va2llLCBzZWNyZXQsIGZpbmFsS2V5KTtcbiAgcmV0dXJuIG9ialtmaW5hbEtleV07XG59O1xuXG4vLyBzcmMvZW5kcG9pbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZUVuZHBvaW50Q3JlYXRvcihvcHRzKSB7XG4gIHJldHVybiAocGF0aCwgb3B0aW9ucywgaGFuZGxlcikgPT4ge1xuICAgIHJldHVybiBjcmVhdGVFbmRwb2ludChcbiAgICAgIHBhdGgsXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHVzZTogWy4uLm9wdGlvbnM/LnVzZSB8fCBbXSwgLi4ub3B0cz8udXNlIHx8IFtdXVxuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRW5kcG9pbnQocGF0aCwgb3B0aW9ucywgaGFuZGxlcikge1xuICBsZXQgcmVzcG9uc2VIZWFkZXIgPSBuZXcgSGVhZGVycygpO1xuICBjb25zdCBoYW5kbGUgPSBhc3luYyAoLi4uY3R4KSA9PiB7XG4gICAgbGV0IGludGVybmFsQ3R4ID0ge1xuICAgICAgc2V0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHNldENvb2tpZShrZXksIHZhbHVlLCBvcHRpb25zMikge1xuICAgICAgICBzZXRDb29raWUocmVzcG9uc2VIZWFkZXIsIGtleSwgdmFsdWUsIG9wdGlvbnMyKTtcbiAgICAgIH0sXG4gICAgICBnZXRDb29raWUoa2V5LCBwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3R4WzBdPy5oZWFkZXJzO1xuICAgICAgICBjb25zdCBjb29raWVIID0gaGVhZGVyPy5nZXQoXCJjb29raWVcIik7XG4gICAgICAgIGNvbnN0IGNvb2tpZSA9IGdldENvb2tpZShjb29raWVIIHx8IFwiXCIsIGtleSwgcHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICAgIH0sXG4gICAgICBnZXRTaWduZWRDb29raWUoa2V5LCBzZWNyZXQsIHByZWZpeCkge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBjdHhbMF0/LmhlYWRlcnM7XG4gICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkhlYWRlcnMgYXJlIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvb2tpZSA9IGdldFNpZ25lZENvb2tpZShoZWFkZXIsIHNlY3JldCwga2V5LCBwcmVmaXgpO1xuICAgICAgICByZXR1cm4gY29va2llO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHNldFNpZ25lZENvb2tpZShrZXksIHZhbHVlLCBzZWNyZXQsIG9wdGlvbnMyKSB7XG4gICAgICAgIGF3YWl0IHNldFNpZ25lZENvb2tpZShyZXNwb25zZUhlYWRlciwga2V5LCB2YWx1ZSwgc2VjcmV0LCBvcHRpb25zMik7XG4gICAgICB9LFxuICAgICAgcmVkaXJlY3QodXJsKSB7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyLnNldChcIkxvY2F0aW9uXCIsIHVybCk7XG4gICAgICAgIHJldHVybiBuZXcgQVBJRXJyb3IoXCJGT1VORFwiKTtcbiAgICAgIH0sXG4gICAgICBqc29uLFxuICAgICAgY29udGV4dDogY3R4WzBdPy5jb250ZXh0IHx8IHt9LFxuICAgICAgX2ZsYWc6IGN0eFswXT8uYXNSZXNwb25zZSA/IFwicm91dGVyXCIgOiBjdHhbMF0/Ll9mbGFnLFxuICAgICAgcmVzcG9uc2VIZWFkZXIsXG4gICAgICBwYXRoLFxuICAgICAgLi4uY3R4WzBdIHx8IHt9XG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy51c2U/Lmxlbmd0aCkge1xuICAgICAgbGV0IG1pZGRsZXdhcmVDb250ZXh0cyA9IHt9O1xuICAgICAgbGV0IG1pZGRsZXdhcmVCb2R5ID0ge307XG4gICAgICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2Ygb3B0aW9ucy51c2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtaWRkbGV3YXJlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJNaWRkbGV3YXJlIGlzIG5vdCBhIGZ1bmN0aW9uXCIsIHtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBtaWRkbGV3YXJlKGludGVybmFsQ3R4KTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIGNvbnN0IGJvZHkgPSByZXMub3B0aW9ucz8uYm9keSA/IHJlcy5vcHRpb25zLmJvZHkucGFyc2UoaW50ZXJuYWxDdHguYm9keSkgOiB2b2lkIDA7XG4gICAgICAgICAgbWlkZGxld2FyZUNvbnRleHRzID0ge1xuICAgICAgICAgICAgLi4ubWlkZGxld2FyZUNvbnRleHRzLFxuICAgICAgICAgICAgLi4ucmVzXG4gICAgICAgICAgfTtcbiAgICAgICAgICBtaWRkbGV3YXJlQm9keSA9IHtcbiAgICAgICAgICAgIC4uLm1pZGRsZXdhcmVCb2R5LFxuICAgICAgICAgICAgLi4uYm9keVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGludGVybmFsQ3R4ID0ge1xuICAgICAgICAuLi5pbnRlcm5hbEN0eCxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIC4uLm1pZGRsZXdhcmVCb2R5LFxuICAgICAgICAgIC4uLmludGVybmFsQ3R4LmJvZHlcbiAgICAgICAgfSxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLmludGVybmFsQ3R4LmNvbnRleHQgfHwge30sXG4gICAgICAgICAgLi4ubWlkZGxld2FyZUNvbnRleHRzXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0aW9ucy5ib2R5ID8gb3B0aW9ucy5ib2R5LnBhcnNlKGludGVybmFsQ3R4LmJvZHkpIDogaW50ZXJuYWxDdHguYm9keTtcbiAgICAgIGludGVybmFsQ3R4ID0ge1xuICAgICAgICAuLi5pbnRlcm5hbEN0eCxcbiAgICAgICAgYm9keTogYm9keSA/IHtcbiAgICAgICAgICAuLi5ib2R5LFxuICAgICAgICAgIC4uLmludGVybmFsQ3R4LmJvZHlcbiAgICAgICAgfSA6IGludGVybmFsQ3R4LmJvZHlcbiAgICAgIH07XG4gICAgICBpbnRlcm5hbEN0eC5xdWVyeSA9IG9wdGlvbnMucXVlcnkgPyBvcHRpb25zLnF1ZXJ5LnBhcnNlKGludGVybmFsQ3R4LnF1ZXJ5KSA6IGludGVybmFsQ3R4LnF1ZXJ5O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgWm9kRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKFwiQkFEX1JFUVVFU1RcIiwge1xuICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSxcbiAgICAgICAgICBkZXRhaWxzOiBlLmVycm9yc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlcXVpcmVIZWFkZXJzICYmICFpbnRlcm5hbEN0eC5oZWFkZXJzKSB7XG4gICAgICB0aHJvdyBuZXcgQVBJRXJyb3IoXCJCQURfUkVRVUVTVFwiLCB7XG4gICAgICAgIG1lc3NhZ2U6IFwiSGVhZGVycyBhcmUgcmVxdWlyZWRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlcXVpcmVSZXF1ZXN0ICYmICFpbnRlcm5hbEN0eC5yZXF1ZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgQVBJRXJyb3IoXCJCQURfUkVRVUVTVFwiLCB7XG4gICAgICAgIG1lc3NhZ2U6IFwiUmVxdWVzdCBpcyByZXF1aXJlZFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXMgPSBhd2FpdCBoYW5kbGVyKGludGVybmFsQ3R4KTtcbiAgICAgIGxldCBhY3R1YWxSZXNwb25zZSA9IHJlcztcbiAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcyA9PT0gXCJvYmplY3RcIiAmJiBcIl9mbGFnXCIgaW4gcmVzKSB7XG4gICAgICAgIGlmIChyZXMuX2ZsYWcgPT09IFwianNvblwiICYmIGludGVybmFsQ3R4Ll9mbGFnID09PSBcInJvdXRlclwiKSB7XG4gICAgICAgICAgY29uc3QgaCA9IHJlcy5yZXNwb25zZS5oZWFkZXJzO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGggfHwge30pLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXIuc2V0KGtleSwgaFtrZXldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNwb25zZUhlYWRlci5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICAgIGFjdHVhbFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHJlcy5yZXNwb25zZS5ib2R5KSwge1xuICAgICAgICAgICAgc3RhdHVzOiByZXMucmVzcG9uc2Uuc3RhdHVzID8/IDIwMCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlcy5yZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3R1YWxSZXNwb25zZSA9IHJlcy5ib2R5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNwb25zZUhlYWRlciA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICByZXR1cm4gYWN0dWFsUmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBUElFcnJvcikge1xuICAgICAgICByZXNwb25zZUhlYWRlci5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICBlLmhlYWRlcnMgPSByZXNwb25zZUhlYWRlcjtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG4gIGhhbmRsZS5wYXRoID0gcGF0aDtcbiAgaGFuZGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICBoYW5kbGUubWV0aG9kID0gb3B0aW9ucy5tZXRob2Q7XG4gIGhhbmRsZS5oZWFkZXJzID0gcmVzcG9uc2VIZWFkZXI7XG4gIHJldHVybiBoYW5kbGU7XG59XG5cbi8vIHNyYy9yb3V0ZXIudHNcbmltcG9ydCB7IGNyZWF0ZVJvdXRlciBhcyBjcmVhdGVSb3UzUm91dGVyLCBhZGRSb3V0ZSwgZmluZFJvdXRlLCBmaW5kQWxsUm91dGVzIH0gZnJvbSBcInJvdTNcIjtcblxuLy8gc3JjL3V0aWxzLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRCb2R5KHJlcXVlc3QpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCI7XG4gIGlmICghcmVxdWVzdC5ib2R5KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSkge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvcm1EYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcIm11bHRpcGFydC9mb3JtLWRhdGFcIikpIHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IGF3YWl0IHJlcXVlc3QuZm9ybURhdGEoKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3JtRGF0YS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidGV4dC9wbGFpblwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIikpIHtcbiAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5hcnJheUJ1ZmZlcigpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3BkZlwiKSB8fCBjb250ZW50VHlwZS5pbmNsdWRlcyhcImltYWdlL1wiKSB8fCBjb250ZW50VHlwZS5pbmNsdWRlcyhcInZpZGVvL1wiKSkge1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXF1ZXN0LmJsb2IoKTtcbiAgICByZXR1cm4gYmxvYjtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9zdHJlYW1cIikgfHwgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gcmVxdWVzdC5ib2R5O1xuICB9XG4gIHJldHVybiBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbn1cbmZ1bmN0aW9uIHNob3VsZFNlcmlhbGl6ZShib2R5KSB7XG4gIHJldHVybiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBib2R5ICE9PSBudWxsICYmICEoYm9keSBpbnN0YW5jZW9mIEJsb2IpICYmICEoYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cbnZhciBzdGF0dXNDb2RlID0ge1xuICBPSzogMjAwLFxuICBDUkVBVEVEOiAyMDEsXG4gIEFDQ0VQVEVEOiAyMDIsXG4gIE5PX0NPTlRFTlQ6IDIwNCxcbiAgTVVMVElQTEVfQ0hPSUNFUzogMzAwLFxuICBNT1ZFRF9QRVJNQU5FTlRMWTogMzAxLFxuICBGT1VORDogMzAyLFxuICBTRUVfT1RIRVI6IDMwMyxcbiAgTk9UX01PRElGSUVEOiAzMDQsXG4gIFRFTVBPUkFSWV9SRURJUkVDVDogMzA3LFxuICBCQURfUkVRVUVTVDogNDAwLFxuICBVTkFVVEhPUklaRUQ6IDQwMSxcbiAgUEFZTUVOVF9SRVFVSVJFRDogNDAyLFxuICBGT1JCSURERU46IDQwMyxcbiAgTk9UX0ZPVU5EOiA0MDQsXG4gIE1FVEhPRF9OT1RfQUxMT1dFRDogNDA1LFxuICBOT1RfQUNDRVBUQUJMRTogNDA2LFxuICBQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRDogNDA3LFxuICBSRVFVRVNUX1RJTUVPVVQ6IDQwOCxcbiAgQ09ORkxJQ1Q6IDQwOSxcbiAgR09ORTogNDEwLFxuICBMRU5HVEhfUkVRVUlSRUQ6IDQxMSxcbiAgUFJFQ09ORElUSU9OX0ZBSUxFRDogNDEyLFxuICBQQVlMT0FEX1RPT19MQVJHRTogNDEzLFxuICBVUklfVE9PX0xPTkc6IDQxNCxcbiAgVU5TVVBQT1JURURfTUVESUFfVFlQRTogNDE1LFxuICBSQU5HRV9OT1RfU0FUSVNGSUFCTEU6IDQxNixcbiAgRVhQRUNUQVRJT05fRkFJTEVEOiA0MTcsXG4gIFwiSSdNX0FfVEVBUE9UXCI6IDQxOCxcbiAgTUlTRElSRUNURURfUkVRVUVTVDogNDIxLFxuICBVTlBST0NFU1NBQkxFX0VOVElUWTogNDIyLFxuICBMT0NLRUQ6IDQyMyxcbiAgRkFJTEVEX0RFUEVOREVOQ1k6IDQyNCxcbiAgVE9PX0VBUkxZOiA0MjUsXG4gIFVQR1JBREVfUkVRVUlSRUQ6IDQyNixcbiAgUFJFQ09ORElUSU9OX1JFUVVJUkVEOiA0MjgsXG4gIFRPT19NQU5ZX1JFUVVFU1RTOiA0MjksXG4gIFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0U6IDQzMSxcbiAgVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlM6IDQ1MSxcbiAgSU5URVJOQUxfU0VSVkVSX0VSUk9SOiA1MDAsXG4gIE5PVF9JTVBMRU1FTlRFRDogNTAxLFxuICBCQURfR0FURVdBWTogNTAyLFxuICBTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG4gIEdBVEVXQVlfVElNRU9VVDogNTA0LFxuICBIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRDogNTA1LFxuICBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUzogNTA2LFxuICBJTlNVRkZJQ0lFTlRfU1RPUkFHRTogNTA3LFxuICBMT09QX0RFVEVDVEVEOiA1MDgsXG4gIE5PVF9FWFRFTkRFRDogNTEwLFxuICBORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEOiA1MTFcbn07XG5cbi8vIHNyYy9yb3V0ZXIudHNcbnZhciBjcmVhdGVSb3V0ZXIgPSAoZW5kcG9pbnRzLCBjb25maWcpID0+IHtcbiAgY29uc3QgX2VuZHBvaW50cyA9IE9iamVjdC52YWx1ZXMoZW5kcG9pbnRzKTtcbiAgY29uc3Qgcm91dGVyID0gY3JlYXRlUm91M1JvdXRlcigpO1xuICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIF9lbmRwb2ludHMpIHtcbiAgICBpZiAoZW5kcG9pbnQub3B0aW9ucy5tZXRhZGF0YT8uU0VSVkVSX09OTFkpIGNvbnRpbnVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVuZHBvaW50Lm9wdGlvbnM/Lm1ldGhvZCkpIHtcbiAgICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIGVuZHBvaW50Lm9wdGlvbnMubWV0aG9kKSB7XG4gICAgICAgIGFkZFJvdXRlKHJvdXRlciwgbWV0aG9kLCBlbmRwb2ludC5wYXRoLCBlbmRwb2ludCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFJvdXRlKHJvdXRlciwgZW5kcG9pbnQub3B0aW9ucy5tZXRob2QsIGVuZHBvaW50LnBhdGgsIGVuZHBvaW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZVJvdXRlciA9IGNyZWF0ZVJvdTNSb3V0ZXIoKTtcbiAgZm9yIChjb25zdCByb3V0ZSBvZiBjb25maWc/LnJvdXRlck1pZGRsZXdhcmUgfHwgW10pIHtcbiAgICBhZGRSb3V0ZShtaWRkbGV3YXJlUm91dGVyLCBcIipcIiwgcm91dGUucGF0aCwgcm91dGUubWlkZGxld2FyZSk7XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IHBhdGggPSB1cmwucGF0aG5hbWU7XG4gICAgaWYgKGNvbmZpZz8uYmFzZVBhdGgpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KGNvbmZpZy5iYXNlUGF0aClbMV07XG4gICAgfVxuICAgIGlmICghcGF0aD8ubGVuZ3RoKSB7XG4gICAgICBjb25maWc/Lm9uRXJyb3I/LihuZXcgQVBJRXJyb3IoXCJOT1RfRk9VTkRcIikpO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW2JldHRlci1jYWxsXTogTWFrZSBzdXJlIHRoZSBVUkwgaGFzIHRoZSBiYXNlUGF0aCAoJHtjb25maWc/LmJhc2VQYXRofSkuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGNvbnN0IHJvdXRlID0gZmluZFJvdXRlKHJvdXRlciwgbWV0aG9kLCBwYXRoKTtcbiAgICBjb25zdCBoYW5kbGVyMiA9IHJvdXRlPy5kYXRhO1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCBnZXRCb2R5KHJlcXVlc3QpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnM7XG4gICAgY29uc3QgcXVlcnkgPSBPYmplY3QuZnJvbUVudHJpZXModXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgY29uc3Qgcm91dGVyTWlkZGxld2FyZSA9IGZpbmRBbGxSb3V0ZXMobWlkZGxld2FyZVJvdXRlciwgXCIqXCIsIHBhdGgpO1xuICAgIGlmICghaGFuZGxlcjIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgbWlkZGxld2FyZUNvbnRleHQgPSB7fTtcbiAgICAgIGlmIChyb3V0ZXJNaWRkbGV3YXJlPy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3V0ZTIgb2Ygcm91dGVyTWlkZGxld2FyZSkge1xuICAgICAgICAgIGNvbnN0IG1pZGRsZXdhcmUgPSByb3V0ZTIuZGF0YTtcbiAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBtaWRkbGV3YXJlKHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgcGFyYW1zOiByb3V0ZTI/LnBhcmFtcyxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgIC4uLmNvbmZpZz8uZXh0cmFDb250ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzPy5fZmxhZyA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkocmVzKSwge1xuICAgICAgICAgICAgICBoZWFkZXJzOiByZXMuaGVhZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAuLi5yZXMsXG4gICAgICAgICAgICAgIC4uLm1pZGRsZXdhcmVDb250ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaGFuZGxlclJlcyA9IGF3YWl0IGhhbmRsZXIyKHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBwYXJhbXM6IHJvdXRlPy5wYXJhbXMsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGJvZHksXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBfZmxhZzogXCJyb3V0ZXJcIixcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLm1pZGRsZXdhcmVDb250ZXh0LFxuICAgICAgICAgIC4uLmNvbmZpZz8uZXh0cmFDb250ZXh0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGhhbmRsZXJSZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlclJlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc0JvZHkgPSBzaG91bGRTZXJpYWxpemUoaGFuZGxlclJlcykgPyBKU09OLnN0cmluZ2lmeShoYW5kbGVyUmVzKSA6IGhhbmRsZXJSZXM7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc0JvZHksIHtcbiAgICAgICAgaGVhZGVyczogaGFuZGxlcjIuaGVhZGVyc1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGNvbmZpZz8ub25FcnJvcikge1xuICAgICAgICBjb25zdCBvbkVycm9yUmVzID0gYXdhaXQgY29uZmlnLm9uRXJyb3IoZSk7XG4gICAgICAgIGlmIChvbkVycm9yUmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gb25FcnJvclJlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBUElFcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGUuYm9keSA/IEpTT04uc3RyaW5naWZ5KGUuYm9keSkgOiBudWxsLCB7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXNDb2RlW2Uuc3RhdHVzXSxcbiAgICAgICAgICBzdGF0dXNUZXh0OiBlLnN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzOiBlLmhlYWRlcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnPy50aHJvd0Vycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIHN0YXR1c1RleHQ6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVyOiBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgY29uc3Qgb25SZXEgPSBhd2FpdCBjb25maWc/Lm9uUmVxdWVzdD8uKHJlcXVlc3QpO1xuICAgICAgaWYgKG9uUmVxIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIG9uUmVxO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxID0gb25SZXEgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gb25SZXEgOiByZXF1ZXN0O1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgaGFuZGxlcihyZXEpO1xuICAgICAgY29uc3Qgb25SZXMgPSBhd2FpdCBjb25maWc/Lm9uUmVzcG9uc2U/LihyZXMpO1xuICAgICAgaWYgKG9uUmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIG9uUmVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGVuZHBvaW50c1xuICB9O1xufTtcblxuLy8gc3JjL21pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmUob3B0aW9uc09ySGFuZGxlciwgaGFuZGxlcikge1xuICBpZiAodHlwZW9mIG9wdGlvbnNPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjcmVhdGVFbmRwb2ludChcbiAgICAgIFwiKlwiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiKlwiXG4gICAgICB9LFxuICAgICAgb3B0aW9uc09ySGFuZGxlclxuICAgICk7XG4gIH1cbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlkZGxld2FyZSBoYW5kbGVyIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGNvbnN0IGVuZHBvaW50ID0gY3JlYXRlRW5kcG9pbnQoXG4gICAgXCIqXCIsXG4gICAge1xuICAgICAgLi4ub3B0aW9uc09ySGFuZGxlcixcbiAgICAgIG1ldGhvZDogXCIqXCJcbiAgICB9LFxuICAgIGhhbmRsZXJcbiAgKTtcbiAgcmV0dXJuIGVuZHBvaW50O1xufVxudmFyIGNyZWF0ZU1pZGRsZXdhcmVDcmVhdG9yID0gKG9wdHMpID0+IHtcbiAgZnVuY3Rpb24gZm4ob3B0aW9uc09ySGFuZGxlciwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRW5kcG9pbnQoXG4gICAgICAgIFwiKlwiLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiBcIipcIlxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zT3JIYW5kbGVyXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pZGRsZXdhcmUgaGFuZGxlciBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgZW5kcG9pbnQgPSBjcmVhdGVFbmRwb2ludChcbiAgICAgIFwiKlwiLFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zT3JIYW5kbGVyLFxuICAgICAgICBtZXRob2Q6IFwiKlwiXG4gICAgICB9LFxuICAgICAgaGFuZGxlclxuICAgICk7XG4gICAgcmV0dXJuIGVuZHBvaW50O1xuICB9XG4gIHJldHVybiBmbjtcbn07XG5cbi8vIHNyYy90eXBlcy50c1xuaW1wb3J0IFwiem9kXCI7XG5cbi8vIHNyYy9hZGFwdGVyL3JlcXVlc3QudHNcbmltcG9ydCAqIGFzIHNldF9jb29raWVfcGFyc2VyIGZyb20gXCJzZXQtY29va2llLXBhcnNlclwiO1xuZnVuY3Rpb24gZ2V0X3Jhd19ib2R5KHJlcSwgYm9keV9zaXplX2xpbWl0KSB7XG4gIGNvbnN0IGggPSByZXEuaGVhZGVycztcbiAgaWYgKCFoW1wiY29udGVudC10eXBlXCJdKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgY29udGVudF9sZW5ndGggPSBOdW1iZXIoaFtcImNvbnRlbnQtbGVuZ3RoXCJdKTtcbiAgaWYgKHJlcS5odHRwVmVyc2lvbk1ham9yID09PSAxICYmIGlzTmFOKGNvbnRlbnRfbGVuZ3RoKSAmJiBoW1widHJhbnNmZXItZW5jb2RpbmdcIl0gPT0gbnVsbCB8fCBjb250ZW50X2xlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBsZW5ndGggPSBjb250ZW50X2xlbmd0aDtcbiAgaWYgKGJvZHlfc2l6ZV9saW1pdCkge1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICBsZW5ndGggPSBib2R5X3NpemVfbGltaXQ7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPiBib2R5X3NpemVfbGltaXQpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgUmVjZWl2ZWQgY29udGVudC1sZW5ndGggb2YgJHtsZW5ndGh9LCBidXQgb25seSBhY2NlcHQgdXAgdG8gJHtib2R5X3NpemVfbGltaXR9IGJ5dGVzLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChyZXEuZGVzdHJveWVkKSB7XG4gICAgY29uc3QgcmVhZGFibGUgPSBuZXcgUmVhZGFibGVTdHJlYW0oKTtcbiAgICByZWFkYWJsZS5jYW5jZWwoKTtcbiAgICByZXR1cm4gcmVhZGFibGU7XG4gIH1cbiAgbGV0IHNpemUgPSAwO1xuICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHJlcS5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgcmVxLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9KTtcbiAgICAgIHJlcS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChzaXplID4gbGVuZ3RoKSB7XG4gICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgcmVxdWVzdCBib2R5IHNpemUgZXhjZWVkZWQgJHtjb250ZW50X2xlbmd0aCA/IFwiJ2NvbnRlbnQtbGVuZ3RoJ1wiIDogXCJCT0RZX1NJWkVfTElNSVRcIn0gb2YgJHtsZW5ndGh9YFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjb250cm9sbGVyLmRlc2lyZWRTaXplID09PSBudWxsIHx8IGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPD0gMCkge1xuICAgICAgICAgIHJlcS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHB1bGwoKSB7XG4gICAgICByZXEucmVzdW1lKCk7XG4gICAgfSxcbiAgICBjYW5jZWwocmVhc29uKSB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgcmVxLmRlc3Ryb3kocmVhc29uKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdCh7XG4gIHJlcXVlc3QsXG4gIGJhc2UsXG4gIGJvZHlTaXplTGltaXRcbn0pIHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KGJhc2UgKyByZXF1ZXN0LnVybCwge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgYm9keTogZ2V0X3Jhd19ib2R5KHJlcXVlc3QsIGJvZHlTaXplTGltaXQpLFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVyc1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldFJlc3BvbnNlKHJlcywgcmVzcG9uc2UpIHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcmVzcG9uc2UuaGVhZGVycykge1xuICAgIHRyeSB7XG4gICAgICByZXMuc2V0SGVhZGVyKFxuICAgICAgICBrZXksXG4gICAgICAgIGtleSA9PT0gXCJzZXQtY29va2llXCIgPyBzZXRfY29va2llX3BhcnNlci5zcGxpdENvb2tpZXNTdHJpbmcocmVzcG9uc2UuaGVhZGVycy5nZXQoa2V5KSkgOiB2YWx1ZVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVzLmdldEhlYWRlck5hbWVzKCkuZm9yRWFjaCgobmFtZSkgPT4gcmVzLnJlbW92ZUhlYWRlcihuYW1lKSk7XG4gICAgICByZXMud3JpdGVIZWFkKDUwMCkuZW5kKFN0cmluZyhlcnJvcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXMud3JpdGVIZWFkKHJlc3BvbnNlLnN0YXR1cyk7XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHJlcy5lbmQoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJlc3BvbnNlLmJvZHkubG9ja2VkKSB7XG4gICAgcmVzLmVuZChcbiAgICAgIFwiRmF0YWwgZXJyb3I6IFJlc3BvbnNlIGJvZHkgaXMgbG9ja2VkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgcmVzcG9uc2Ugd2FzIGFscmVhZHkgcmVhZCAoZm9yIGV4YW1wbGUgdGhyb3VnaCAncmVzcG9uc2UuanNvbigpJyBvciAncmVzcG9uc2UudGV4dCgpJykuXCJcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICBpZiAocmVzLmRlc3Ryb3llZCkge1xuICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY2FuY2VsID0gKGVycm9yKSA9PiB7XG4gICAgcmVzLm9mZihcImNsb3NlXCIsIGNhbmNlbCk7XG4gICAgcmVzLm9mZihcImVycm9yXCIsIGNhbmNlbCk7XG4gICAgcmVhZGVyLmNhbmNlbChlcnJvcikuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICAgIGlmIChlcnJvcikgcmVzLmRlc3Ryb3koZXJyb3IpO1xuICB9O1xuICByZXMub24oXCJjbG9zZVwiLCBjYW5jZWwpO1xuICByZXMub24oXCJlcnJvclwiLCBjYW5jZWwpO1xuICBuZXh0KCk7XG4gIGFzeW5jIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICAgIGlmICghcmVzLndyaXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJlcy5vbmNlKFwiZHJhaW5cIiwgbmV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMuZW5kKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhbmNlbChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvYWRhcHRlci9ub2RlLnRzXG5mdW5jdGlvbiB0b05vZGVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICAgIGNvbnN0IHByb3RvY29sID0gcmVxLmNvbm5lY3Rpb24/LmVuY3J5cHRlZCA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiO1xuICAgIGNvbnN0IGJhc2UgPSBgJHtwcm90b2NvbH06Ly8ke3JlcS5oZWFkZXJzW1wiOmF1dGhvcml0eVwiXSB8fCByZXEuaGVhZGVycy5ob3N0fWA7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyKGdldFJlcXVlc3QoeyBiYXNlLCByZXF1ZXN0OiByZXEgfSkpO1xuICAgIHNldFJlc3BvbnNlKHJlcywgcmVzcG9uc2UpO1xuICB9O1xufVxuZXhwb3J0IHtcbiAgQVBJRXJyb3IsXG4gIGNyZWF0ZUVuZHBvaW50LFxuICBjcmVhdGVFbmRwb2ludENyZWF0b3IsXG4gIGNyZWF0ZU1pZGRsZXdhcmUsXG4gIGNyZWF0ZU1pZGRsZXdhcmVDcmVhdG9yLFxuICBjcmVhdGVSb3V0ZXIsXG4gIGdldEJvZHksXG4gIGdldENvb2tpZSxcbiAgZ2V0UmVxdWVzdCxcbiAgZ2V0U2lnbmVkQ29va2llLFxuICBwYXJzZSxcbiAgcGFyc2VTaWduZWQsXG4gIHNlcmlhbGl6ZSxcbiAgc2VyaWFsaXplU2lnbmVkLFxuICBzZXRDb29raWUsXG4gIHNldFJlc3BvbnNlLFxuICBzZXRTaWduZWRDb29raWUsXG4gIHNob3VsZFNlcmlhbGl6ZSxcbiAgc2lnbkNvb2tpZVZhbHVlLFxuICBzdGF0dXNDb2RlLFxuICB0b05vZGVIYW5kbGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/better-call/dist/index.js\n");

/***/ })

};
;